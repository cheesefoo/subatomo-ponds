<html>
<head>
    <style>
        #canvas-container {
            position: relative;
            width: 300px;
            height: 300px;
            box-shadow: 0 0 5px 1px black;
            margin: 10px auto;
            border: 5px solid transparent;
            display: inline-block;;
        }

        #canvas-container.over {
            border: 5px dashed cyan;
        }

        #images img.img_dragging {
            opacity: 0.4;
        }

        /*
        Styles below based on  http://www.html5rocks.com/en/tutorials/dnd/basics/
        */

        /* Prevent the text contents of draggable elements from being selectable. */
        [draggable] {
            -moz-user-select: none;
            -khtml-user-select: none;
            -webkit-user-select: none;
            user-select: none;
            /* Required to make elements draggable in old WebKit */
            -khtml-user-drag: element;
            -webkit-user-drag: element;
            cursor: move;
        }

        .editor-container {
            display: flex;
            flex-wrap: wrap;
            flex-direction: row;
        }

        #images {
            width: 120px;
            background-color: olive;
            padding: 20px;
        }

        /*#spritesheet{width:200px;}*/
    </style>


    <script src="http://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/1.5.0/fabric.js"></script>

</head>

<body onload="init();">
<!-- Based on the tutorial at http://www.html5rocks.com/en/tutorials/dnd/basics/ -->
<h1 style="text-align:center;">Duck editor</h1>
<img crossOrigin="Anonymous" id="duck" src="1.png" style=" position:fixed; top:-10000px; left:-10000px;"></img>
<img crossOrigin="Anonymous" id="duck2" src="2.png" style=" position:fixed; top:-10000px; left:-10000px;"></img>
<img crossOrigin="Anonymous" id="duck3" src="3.png" style=" position:fixed; top:-10000px; left:-10000px;"></img>
<img crossOrigin="Anonymous" id="duck4" src="4.png" style=" position:fixed; top:-10000px; left:-10000px;"></img>
<div class="editor-container">
    <div id="images">
        <h3>Objects</h3>
        <!--<img draggable="true" src="http://i.imgur.com/8rmMZI3.jpg" width="100" height="100"></img>
        <img draggable="true" src="http://i.imgur.com/q9aLMza.png" width="100" height="100"></img>!-->
        <img crossOrigin="Anonymous" draggable="true" src="hat1.png" width="100"></img>
        <img crossOrigin="Anonymous" draggable="true" src="hat2.png" width="100"></img>
        <img crossOrigin="Anonymous" draggable="true" src="hat3.png" width="100"></img>
        <img crossOrigin="Anonymous" draggable="true" src="baseballhat.png" width="100"></img>
        <img crossOrigin="Anonymous" draggable="true" src="bow1.png" width="100"></img>
        <img crossOrigin="Anonymous" draggable="true" src="bow2.png" width="100"></img>

    </div>

    <!-- NOTE: Fabric.js sets both the <canvas> element and the wrapper element which it
    creates to be user-unselectable using CSS properties (e.g. for Webkit, this is
    -webkit-user-select: none;). We could remove that property during the dragging, but
    I'm just going to wrap the canvas in a container and bind events to that, which is
    less intrusive.
     -->
    <div id="canvas-container">
        <canvas height="300" id="canvas" width="300"></canvas>
    </div>

    <div style="display: inline-block; margin-left: 10px; width:300px;background-color:olive;padding:20px;">
        <h3>Drawing</h3>
        <button class="btn btn-info" id="drawing-mode">Enter drawing mode</button>
        <br>
        <button class="btn btn-info" id="clear-canvas">Clear</button>
        <br>

        <div id="drawing-mode-options" style="display:none;">
            <label for="drawing-mode-selector">Mode:</label>
            <select id="drawing-mode-selector">
                <option>Pencil</option>
                <option>Circle</option>
                <option>Spray</option>
                <option>Pattern</option>

                <option>hline</option>
                <option>vline</option>
                <option>square</option>
                <option>diamond</option>
                <option>texture</option>
            </select><br>

            <label for="drawing-line-width">Line width:</label>
            <span class="info">8</span><input id="drawing-line-width" max="150" min="0" type="range" value="8"><br>

            <label for="drawing-color">Line color:</label>
            <input id="drawing-color" type="color" value="#005E7A"><br>

            <label for="drawing-shadow-color">Shadow color:</label>
            <input id="drawing-shadow-color" type="color" value="#005E7A"><br>

            <label for="drawing-shadow-width">Shadow width:</label>
            <span class="info">16</span><input id="drawing-shadow-width" max="50" min="0" type="range" value="0"><br>

            <label for="drawing-shadow-offset">Shadow offset:</label>
            <span class="info">0</span><input id="drawing-shadow-offset" max="50" min="0" type="range" value="0"><br>
        </div>
    </div>
</div>
<canvas height="300" id="source" width="300"></canvas>
<canvas height="300" id="copy" width="300"></canvas>

<canvas height="400" id="spritesheet" style="border:1px solid black;" width="400"></canvas>

<script>

    let canvas;

    let ducks = [];

    function addDuck() {
        ducks = [];
        let duckimg = document.querySelector("#duck");

        let duck = new fabric.Image(duckimg, {
            width: duckimg.width,
            height: duckimg.height,
            left: 0,
            top: 0,
            evented: false,
            selectable: false
        });
        canvas.add(duck);
        ducks.push(duck);

        duckimg = document.querySelector('#duck2');

        duck = new fabric.Image(duckimg, {
            width: duckimg.width,
            height: duckimg.height,
            left: 0,
            top: 0,
            evented: false,
            selectable: false
        });
        duck.opacity = 0;
        canvas.add(duck);
        ducks.push(duck);

        duckimg = document.querySelector('#duck3');

        duck = new fabric.Image(duckimg, {
            width: duckimg.width,
            height: duckimg.height,
            left: 0,
            top: 0,
            evented: false,
            selectable: false
        });
        duck.opacity = 0;
        canvas.add(duck);
        ducks.push(duck);

        duckimg = document.querySelector('#duck4');

        duck = new fabric.Image(duckimg, {
            width: duckimg.width,
            height: duckimg.height,
            left: 0,
            top: 0,
            evented: false,
            selectable: false
        });
        duck.opacity = 0;
        canvas.add(duck);
        ducks.push(duck);

        canvas.renderAll()
    }

    function init() {
        const $ = function (id) {
            return document.getElementById(id);
        };


        /* Drag and Drop code adapted from http://www.html5rocks.com/en/tutorials/dnd/basics/ */

        canvas = new fabric.Canvas('canvas', {
            isDrawingMode: false
        });

        addDuck();


        /*
        NOTE: the start and end handlers are events for the <img> elements; the rest are bound to
        the canvas container.
        */

        function handleDragStart(e) {
            [].forEach.call(images, function (img) {
                img.classList.remove('img_dragging');
            });
            this.classList.add('img_dragging');
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault(); // Necessary. Allows us to drop.
            }

            e.dataTransfer.dropEffect = 'copy'; // See the section on the DataTransfer object.
            // NOTE: comment above refers to the article (see top) -natchiketa

            return false;
        }

        function handleDragEnter(e) {
            // this / e.target is the current hover target.
            this.classList.add('over');
        }

        function handleDragLeave(e) {
            this.classList.remove('over'); // this / e.target is previous target element.
        }

        function handleDrop(e) {
            // this / e.target is current target element.

            if (e.stopPropagation) {
                e.stopPropagation(); // stops the browser from redirecting.
            }

            const img = document.querySelector("#images img.img_dragging");

            console.log('event: ', e);

            console.log(img);

            const newImage = new fabric.Image(img, {
                width: img.width,
                height: img.height,
                // Set the center of the new object based on the event coordinates relative
                // to the canvas container.
                left: e.layerX,
                top: e.layerY
            });
            canvas.add(newImage);

            return false;
        }

        function handleDragEnd(e) {
            // this/e.target is the source node.
            [].forEach.call(images, function (img) {
                img.classList.remove('img_dragging');
            });
        }

        if (Modernizr.draganddrop) {
            // Browser supports HTML5 DnD.

            // Bind the event listeners for the image elements
            const images = document.querySelectorAll("#images img");
            [].forEach.call(images, function (img) {
                img.addEventListener('dragstart', handleDragStart, false);
                img.addEventListener('dragend', handleDragEnd, false);
            });
            // Bind the event listeners for the canvas
            const canvasContainer = document.getElementById("canvas-container");
            canvasContainer.addEventListener('dragenter', handleDragEnter, false);
            canvasContainer.addEventListener('dragover', handleDragOver, false);
            canvasContainer.addEventListener('dragleave', handleDragLeave, false);
            canvasContainer.addEventListener('drop', handleDrop, false);
        } else {
            // Replace with a fallback to a library solution.
            alert("This browser doesn't support the HTML5 Drag and Drop API.");
        }


        const drawingModeEl = $("drawing-mode"),
            drawingOptionsEl = $("drawing-mode-options"),
            drawingColorEl = $("drawing-color"),
            drawingShadowColorEl = $("drawing-shadow-color"),
            drawingLineWidthEl = $("drawing-line-width"),
            drawingShadowWidth = $("drawing-shadow-width"),
            drawingShadowOffset = $("drawing-shadow-offset"),
            clearEl = $("clear-canvas");

        clearEl.onclick = function () {
            canvas.clear();
            addDuck()
        };

        drawingModeEl.onclick = function () {
            canvas.isDrawingMode = !canvas.isDrawingMode;
            if (canvas.isDrawingMode) {
                drawingModeEl.innerHTML = 'Cancel drawing mode';
                drawingOptionsEl.style.display = '';
            } else {
                drawingModeEl.innerHTML = 'Enter drawing mode';
                drawingOptionsEl.style.display = 'none';
            }
        };

        if (fabric.PatternBrush) {
            const vLinePatternBrush = new fabric.PatternBrush(canvas);
            vLinePatternBrush.getPatternSrc = function () {

                const patternCanvas = fabric.document.createElement("canvas");
                patternCanvas.width = patternCanvas.height = 10;
                const ctx = patternCanvas.getContext("2d");

                ctx.strokeStyle = this.color;
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(0, 5);
                ctx.lineTo(10, 5);
                ctx.closePath();
                ctx.stroke();

                return patternCanvas;
            };

            const hLinePatternBrush = new fabric.PatternBrush(canvas);
            hLinePatternBrush.getPatternSrc = function () {

                const patternCanvas = fabric.document.createElement("canvas");
                patternCanvas.width = patternCanvas.height = 10;
                const ctx = patternCanvas.getContext("2d");

                ctx.strokeStyle = this.color;
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(5, 0);
                ctx.lineTo(5, 10);
                ctx.closePath();
                ctx.stroke();

                return patternCanvas;
            };

            const squarePatternBrush = new fabric.PatternBrush(canvas);
            squarePatternBrush.getPatternSrc = function () {

                const squareWidth = 10, squareDistance = 2;

                const patternCanvas = fabric.document.createElement("canvas");
                patternCanvas.width = patternCanvas.height = squareWidth + squareDistance;
                const ctx = patternCanvas.getContext("2d");

                ctx.fillStyle = this.color;
                ctx.fillRect(0, 0, squareWidth, squareWidth);

                return patternCanvas;
            };

            const diamondPatternBrush = new fabric.PatternBrush(canvas);
            diamondPatternBrush.getPatternSrc = function () {

                const squareWidth = 10, squareDistance = 5;
                const patternCanvas = fabric.document.createElement("canvas");
                const rect = new fabric.Rect({
                    width: squareWidth,
                    height: squareWidth,
                    angle: 45,
                    fill: this.color
                });

                const canvasWidth = rect.getBoundingRect().width;

                patternCanvas.width = patternCanvas.height = canvasWidth + squareDistance;
                rect.set({left: canvasWidth / 2, top: canvasWidth / 2});

                const ctx = patternCanvas.getContext("2d");
                rect.render(ctx);

                return patternCanvas;
            };

            var img = new Image();
            img.src = 'honey_im_subtle.png';

            var texturePatternBrush = new fabric.PatternBrush(canvas);
            texturePatternBrush.source = img;
        }

        $('drawing-mode-selector').onchange = function () {

            if (this.value === 'hline') {
                canvas.freeDrawingBrush = vLinePatternBrush;
            } else if (this.value === 'vline') {
                canvas.freeDrawingBrush = hLinePatternBrush;
            } else if (this.value === 'square') {
                canvas.freeDrawingBrush = squarePatternBrush;
            } else if (this.value === 'diamond') {
                canvas.freeDrawingBrush = diamondPatternBrush;
            } else if (this.value === 'texture') {
                canvas.freeDrawingBrush = texturePatternBrush;
            } else {
                canvas.freeDrawingBrush = new fabric[this.value + 'Brush'](canvas);
            }

            if (canvas.freeDrawingBrush) {
                const brush = canvas.freeDrawingBrush;
                brush.color = drawingColorEl.value;
                if (brush.getPatternSrc) {
                    brush.source = brush.getPatternSrc.call(brush);
                }
                brush.width = parseInt(drawingLineWidthEl.value, 10) || 1;
                brush.shadow = new fabric.Shadow({
                    blur: parseInt(drawingShadowWidth.value, 10) || 0,
                    offsetX: 0,
                    offsetY: 0,
                    affectStroke: true,
                    color: drawingShadowColorEl.value,
                });
            }
        };

        drawingColorEl.onchange = function () {
            const brush = canvas.freeDrawingBrush;
            brush.color = this.value;
            if (brush.getPatternSrc) {
                brush.source = brush.getPatternSrc.call(brush);
            }
        };
        drawingShadowColorEl.onchange = function () {
            canvas.freeDrawingBrush.shadow.color = this.value;
        };
        drawingLineWidthEl.onchange = function () {
            canvas.freeDrawingBrush.width = parseInt(this.value, 10) || 1;
            this.previousSibling.innerHTML = this.value;
        };
        drawingShadowWidth.onchange = function () {
            canvas.freeDrawingBrush.shadow.blur = parseInt(this.value, 10) || 0;
            this.previousSibling.innerHTML = this.value;
        };
        drawingShadowOffset.onchange = function () {
            canvas.freeDrawingBrush.shadow.offsetX = parseInt(this.value, 10) || 0;
            canvas.freeDrawingBrush.shadow.offsetY = parseInt(this.value, 10) || 0;
            this.previousSibling.innerHTML = this.value;
        };

        if (canvas.freeDrawingBrush) {
            canvas.freeDrawingBrush.color = drawingColorEl.value;
            console.log(canvas.freeDrawingBrush);
            if (canvas.freeDrawingBrush.getPatternSrc) {
                canvas.freeDrawingBrush.source = canvas.freeDrawingBrush.getPatternSrc.call(this);
            }
            canvas.freeDrawingBrush.width = parseInt(drawingLineWidthEl.value, 10) || 1;
            canvas.freeDrawingBrush.shadow = new fabric.Shadow({
                blur: parseInt(drawingShadowWidth.value, 10) || 0,
                offsetX: 0,
                offsetY: 0,
                affectStroke: true,
                color: drawingShadowColorEl.value,
            });
        }
    };


    function drawSpriteSheet(x = 0, y = 0, dindex = 0) {
        for (var a = 0; a < ducks.length; a++) {
            ducks[a].opacity = 0;
        }
        ducks[dindex].opacity = 1;

        canvas.renderAll()

        canvas.deactivateAll().renderAll();

        const sheet = document.getElementById("spritesheet");
        const duckCan = document.getElementById("canvas");
        const source = document.getElementById("source");
        const copy = document.getElementById("copy");

        const sourceCtx = source.getContext("2d");
        const copyCtx = copy.getContext("2d");
        const sheetCtx = sheet.getContext("2d");

        //call its drawImage() function passing it the source canvas directly

        let auxWidth = 300;
        const destination = 200;
        const step = 100;

        copyCtx.drawImage(duckCan, 0, 0, auxWidth, auxWidth, 0, 0, auxWidth, auxWidth);

        for (var a = 0; auxWidth > destination; a++) {
            sourceCtx.clearRect(0, 0, 300, 300);
            sourceCtx.drawImage(copy, 0, 0, auxWidth, auxWidth, 0, 0, auxWidth, auxWidth);

            copyCtx.clearRect(0, 0, 300, 300);

            copyCtx.drawImage(source, 0, 0, auxWidth, auxWidth, 0, 0, auxWidth - step, auxWidth - step);

            //copyCtx.drawImage(aux, 0, 0,280,300,0,0,250,250);

            auxWidth -= step;
        }
        sheetCtx.drawImage(copy, 0, 0, auxWidth, auxWidth, x, y, auxWidth, auxWidth);
        sourceCtx.clearRect(0, 0, 300, 300);
        copyCtx.clearRect(0, 0, 300, 300);
        //destCtx.drawImage(duckCan, 300, 0);
        //destCtx.drawImage(duckCan, 0, 300);
        //destCtx.drawImage(duckCan, 300, 300);

    }

</script>

<div style="text-align:center;">
    <button onclick="drawSpriteSheet();drawSpriteSheet(200,0,1);drawSpriteSheet(0,200,2);drawSpriteSheet(200,200,3);" style="margin:auto; font-size:20px; padding:10px;"
            type="button">
        Save duck
    </button>
</div>
<a id="link"></a>

<script>
    function download() {
        const link = document.getElementById("link");
        link.setAttribute('download', 'avatar.png');
        link.setAttribute('href', canvas.toDataURL("image/png").replace("image/png", "image/octet-stream"));
        link.click();
    }
</script>

</body>

</html>
